二叉树的前序遍历遵循 **根节点 -> 左子树 -> 右子树** 的顺序。非递归实现巧妙地借助 **栈** 来模拟递归调用的过程，从而避免使用系统调用栈。其核心思想是：在向左子树深入的过程中访问节点并压栈，左子树为空时则回溯至上一节点并转向其右子树继续处理。

以下是基于C++的实现代码示例、算法步骤说明以及一个简单的例子。

### 📝 代码实现

```
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

vector<int> preorderTraversal(TreeNode* root) {
    vector<int> res; // 用于存储遍历结果的容器
    if (root == nullptr) return res; // 如果树为空，直接返回空结果

    stack<TreeNode*> st; // 辅助栈，用于模拟递归调用栈
    TreeNode* cur = root; // 从根节点开始

    while (cur != nullptr || !st.empty()) {
        // 1. 一路向左访问节点并压栈
        while (cur != nullptr) {
            res.push_back(cur->val); // 访问当前节点（根）
            st.push(cur);           // 将当前节点压入栈，以便后续回溯找其右子树
            cur = cur->left;        // 转向左子树
        }
        // 2. 左子树为空时，回溯到父节点并转向其右子树
        cur = st.top();
        st.pop();
        cur = cur->right; // 转向右子树
    }
    return res;
}
```

### 🧠 算法步骤拆解

1. **初始化**：创建一个空栈 `st`和一个空列表 `res`用于存储结果。将当前节点 `cur`初始化为根节点 `root`。
2. **外层循环**：只要当前节点 `cur`不为空 **或者** 栈 `st`非空，就继续循环。
3. **内层循环（深入左子树）**：当 `cur`不为空时： 访问当前节点 `cur`的值并将其加入 `res`。 将 `cur`压入栈 `st`，以便之后回溯。 将 `cur`更新为其左子节点，继续向左深入。
4. **回溯并转向右子树**：当 `cur`为空（表示左子树已遍历完）时： 弹出栈顶元素，它就是最近访问过的那个节点（即当前子树的根）。 将 `cur`更新为该弹出节点的右子节点，开始遍历右子树。
5. **循环结束**：当 `cur`为空且栈 `st`也为空时，说明所有节点都已遍历完毕，返回结果 `res`。

### 🧩 示例

假设有这样一棵简单的二叉树：

```
1
   / \
  2   3
```

它的前序遍历顺序是 `1 -> 2 -> 3`。

让我们结合上面的算法，跟踪一下栈 `st`和结果列表 `res`的变化：

| 步骤 | 当前节点 (cur) | 栈操作         | 栈内容 (栈底->栈顶) | 访问节点 (res) | 说明                                                |
| ---- | -------------- | -------------- | ------------------- | -------------- | --------------------------------------------------- |
| 1    | 1 (根节点)     | push(1)        | [1]                 | 1              | 访问根节点1，并入栈，然后转向左子节点2              |
| 2    | 2              | push(2)        | [1, 2]              | 1, 2           | 访问节点2，并入栈，然后转向左子节点 (null)          |
| 3    | nullptr        | pop() -> 得到2 | [1]                 | 1, 2           | 左尽头，回溯至栈顶节点2，并转向其右子节点(null)     |
| 4    | nullptr        | pop() -> 得到1 | []                  | 1, 2           | 节点2的右子树为空，继续回溯至节点1，转向其右子节点3 |
| 5    | 3              | push(3)        | [3]                 | 1, 2, 3        | 访问节点3，并入栈，然后转向左子节点 (null)          |
| 6    | nullptr        | pop() -> 得到3 | []                  | 1, 2, 3        | 左尽头，回溯至节点3，转向其右子节点 (null)          |
| 7    | nullptr        | -              | []                  | 1, 2, 3        | 栈空，遍历结束                                      |

最终得到的前序遍历结果就是 `[1, 2, 3]`。

### ⚙️ 复杂度分析

- **时间复杂度**：**O(n)**，其中 n 是二叉树的节点数。每个节点恰好被访问一次。
- **空间复杂度**：**O(n)**，最坏情况下（二叉树退化成一条链），栈需要存储所有节点。

### 💡 其他实现思路

除了上述常见的“一路向左”方法，搜索结果还提到了另一种思路，其代码可能略有不同，但核心思想一致：

```
vector<int> preorderTraversal2(TreeNode *root) {
    vector<int> ret;
    if (root == NULL) return ret;
    stack<TreeNode*> s;
    s.push(root);
    TreeNode* tmpNode = NULL;
    while(!s.empty()) {
        tmpNode = s.top();
        s.pop();
        ret.push_back(tmpNode->val); // 访问根节点
        // 先压入右孩子，再压入左孩子，这样出栈顺序才是先左后右
        if (tmpNode->right != NULL) s.push(tmpNode->right);
        if (tmpNode->left != NULL) s.push(tmpNode->left);
    }
    return ret;
}
```

这种方法在访问根节点后，先将其右孩子入栈，再将其左孩子入栈，利用栈的LIFO特性，保证下一次先处理左孩子。

希望这些解释和示例能帮助你理解二叉树前序遍历的非递归实现。