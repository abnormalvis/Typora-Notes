计算二叉树的高度（层数）是数据结构中的常见操作。下面我用递归和非递归（层次遍历）两种方法为你介绍如何用C++实现，并提供对比和示例。

### 🌳 二叉树高度定义

二叉树的高度（Height）是指从根节点到最远叶子节点的**最长路径上的节点数**。根据这个定义：

- 空树的高度为 0。
- 只有一个根节点的树高度为 1。

### 📊 方法对比

以下是递归和非递归方法的主要特点对比，你可以根据需求选择。

| 特性           | 递归方法                             | 非递归方法（层次遍历）                |
| -------------- | ------------------------------------ | ------------------------------------- |
| **时间复杂度** | O(n)                                 | O(n)                                  |
| **空间复杂度** | O(h)，h为树高，最坏情况下为O(n)      | O(w)，w为树最大宽度，最坏情况下为O(n) |
| **实现难度**   | 简单直观                             | 稍复杂                                |
| **核心思想**   | 将问题分解为求解左右子树高度的子问题 | 按层遍历，统计层数                    |
| **优点**       | 代码简洁，易于理解                   | 避免递归深度过大导致的栈溢出          |
| **缺点**       | 递归调用可能栈溢出（对于非常深的树） | 需要维护辅助队列                      |

### ⌨️ 代码实现

下面是两种方法的C++实现。二叉树节点定义如下：

```
#include <iostream>
#include <queue>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

#### 方法 1：递归方法

递归方法简洁直观，其思想是二叉树的高度等于其**左右子树高度的最大值加 1**。

```
int getHeightRecursive(TreeNode* root) {
    if (root == nullptr) {
        return 0; // 空树高度为0
    }
    int leftHeight = getHeightRecursive(root->left);   // 递归计算左子树高度
    int rightHeight = getHeightRecursive(root->right); // 递归计算右子树高度
    return max(leftHeight, rightHeight) + 1; // 返回较大子树高度加1
}
```

#### 方法 2：非递归方法（层次遍历）

非递归方法利用**队列**进行广度优先搜索（BFS），统计遍历的层数。

```
int getHeightLevelOrder(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }
    
    queue<TreeNode*> q;
    q.push(root);
    int height = 0;
    
    while (!q.empty()) {
        int levelSize = q.size(); // 当前层的节点数
        height++; // 处理完一层，高度加1
        
        for (int i = 0; i < levelSize; ++i) {
            TreeNode* node = q.front();
            q.pop();
            
            if (node->left != nullptr) {
                q.push(node->left);
            }
            if (node->right != nullptr) {
                q.push(node->right);
            }
        }
    }
    return height;
}
```

### 🧪 示例和使用

你可以这样构建二叉树并测试函数：

```
int main() {
    // 构建一个简单的二叉树：
    //       1
    //      / \
    //     2   3
    //    /
    //   4
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);

    cout << "递归计算高度: " << getHeightRecursive(root) << endl;     // 输出 3
    cout << "层次遍历高度: " << getHeightLevelOrder(root) << endl; // 输出 3

    // 释放内存（实际程序中别忘了这一步）
    delete root->left->left;
    delete root->left;
    delete root->right;
    delete root;

    return 0;
}
```

### 💡 提示与注意事项

- **节点定义**：根据你的实际情况调整 `TreeNode`结构体。
- **内存管理**：示例中使用了 `new`来构建树，在实际程序中一定要注意使用 `delete`来释放内存，防止内存泄漏。对于复杂树，建议写一个专门的销毁函数（通常也使用递归后序遍历）。
- **选择方法**： 对于**树深度不是特别大**的情况，**递归方法**代码简洁，是常见选择。 如果树**非常深**，为了避免递归调用栈溢出（Stack Overflow），应选择**非递归的层次遍历方法**。 层次遍历方法虽然代码长一点，但它是 **BFS** 的典型应用，掌握它有助于理解更复杂的算法。

希望这些解释和代码能帮助你理解和实现二叉树高度的计算。