二分查找是一种在**有序数组**中查找特定元素的高效算法。其核心思想是通过不断将搜索区间减半来快速定位目标值。

## 算法原理

1. 确定搜索区间的起始点 `left` 和结束点 `right`
2. 计算中间位置 `mid`
3. 比较中间元素与目标值：
   - 相等：找到目标，返回索引
   - 中间元素 < 目标值：在右半部分继续搜索
   - 中间元素 > 目标值：在左半部分继续搜索
4. 重复直到找到目标或区间为空

## C++ 实现

### 迭代版本
```cpp
#include <vector>
using namespace std;

int binarySearch(const vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // 防止溢出
        
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;  // 未找到
}
```

### 递归版本
```cpp
int binarySearchRecursive(const vector<int>& nums, int target, int left, int right) {
    if (left > right) {
        return -1;
    }
    
    int mid = left + (right - left) / 2;
    
    if (nums[mid] == target) {
        return mid;
    } else if (nums[mid] < target) {
        return binarySearchRecursive(nums, target, mid + 1, right);
    } else {
        return binarySearchRecursive(nums, target, left, mid - 1);
    }
}
```

## 复杂度分析

### 时间复杂度：O(log n)

**推导过程：**
- 每次迭代都将搜索范围缩小一半
- 最坏情况下，搜索区间变化：n → n/2 → n/4 → ... → 1
- 设需要 k 次迭代：n × (1/2)^k = 1
- 解得：k = log₂n
- 因此时间复杂度为 **O(log n)**

### 空间复杂度：
- **迭代版本**：O(1)，只使用了固定数量的变量
- **递归版本**：O(log n)，由于递归调用栈的深度

## 使用示例
```cpp
#include <iostream>
#include <vector>

int main() {
    vector<int> nums = {1, 3, 5, 7, 9, 11, 13, 15};
    int target = 7;
    
    int result = binarySearch(nums, target);
    
    if (result != -1) {
        cout << "找到目标值 " << target << "，索引为 " << result << endl;
    } else {
        cout << "未找到目标值 " << target << endl;
    }
    
    return 0;
}
```

## 注意事项

1. **数组必须有序**：二分查找的前提条件
2. **防止整数溢出**：使用 `mid = left + (right - left) / 2` 而不是 `(left + right) / 2`
3. **边界条件**：注意循环条件是 `left <= right` 还是 `left < right`

二分查找因其高效性被广泛应用于各种场景，是算法学习中的重要基础。