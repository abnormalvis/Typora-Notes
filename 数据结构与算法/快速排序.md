快速排序（Quick Sort）是一种基于**分治法**（Divide and Conquer）的高效排序算法，由 **C. A. R. Hoare**（东尼·霍尔）在 **1960年** 提出。它的核心思想是通过一趟排序将待排序列分割成独立的两部分，其中一部分的所有元素均比另一部分的所有元素小，然后再分别对这两部分递归地进行快速排序，以此达到整个序列有序。

以下是快速排序的核心要点梳理：

| 特性           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| **基本思想**   | 分治法。选取一个基准元素，将数组分割为两个子数组，左边均小于基准，右边均大于基准，然后递归处理子数组。 |
| **时间复杂度** | • **平均情况**：O(n log n) • **最好情况**（均匀划分）：O(n log n) • **最坏情况**（已排序或逆序）：O(n²) |
| **空间复杂度** | 主要为递归调用栈的空间： • **平均情况**：O(log n) • **最坏情况**：O(n) |
| **稳定性**     | **不稳定**。相等元素的相对位置可能在分区过程中改变。         |
| **关键步骤**   | 1. **选择基准**（Pivot） 2. **分区操作**（Partitioning） 3. **递归排序**子数组 |
| **优化策略**   | • 随机选择基准 • 三数取中法 • 小数组切换为插入排序           |

### 🔄 工作原理详解

快速排序的核心是 **分区操作**（Partition），其步骤如下：

1. **选择基准值（Pivot）**：从数组中选择一个元素作为基准。常见选择有第一个元素、最后一个元素、中间元素或随机元素。
2. **重排数组（分区）**： 设定两个指针（或索引）`i`和 `j`，通常 `i`从序列起始开始，`j`从序列末尾开始。 向右移动 `i`，直到找到一个**大于或等于**基准值的元素。 向左移动 `j`，直到找到一个**小于或等于**基准值的元素。 如果 `i`仍在 `j`的左侧，则交换 `i`和 `j`所指的元素。 重复上述步骤，直到 `i`和 `j`相遇或交错。 将基准值放置到其最终的正确位置（相遇点），此时基准值左侧的所有元素均小于等于基准值，右侧的所有元素均大于等于基准值。
3. **递归排序子数组**：递归地将上述过程应用于基准值左边和右边的子数组。

### 🖥️ 代码实现

#### Python 示例

这是一种易于理解的实现方式，但创建了新列表，并非严格的原地排序：

```
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]  # 选择中间元素作为基准
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# 示例用法
sample_array = [3, 6, 8, 10, 1, 2, 1]
sorted_array = quick_sort(sample_array)
print(sorted_array)  # 输出: [1, 1, 2, 3, 6, 8, 10]
```

*citation:3]*

#### Java 示例（原地排序）

这是一种更高效的原位排序版本：

```
import java.util.Arrays;

public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {2, 56, 8, 45, 6, 25};
        quickSort(arr, 0, arr.length - 1);
        System.out.println("排序结果: " + Arrays.toString(arr));
    }

    public static void quickSort(int[] arr, int left, int right) {
        if (left >= right) return;
        int base = arr[left]; // 选择第一个元素为基准
        int i = left, j = right;
        while (i != j) {
            while (arr[j] >= base && i < j) j--; // 右指针左移
            while (arr[i] <= base && i < j) i++; // 左指针右移
            if (i < j) swap(arr, i, j); // 交换
        }
        swap(arr, left, i); // 基准归位
        quickSort(arr, left, i - 1); // 递归左子数组
        quickSort(arr, i + 1, right); // 递归右子数组
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

*citation:5]*

### ⚙️ 优化策略

为了避免最坏情况下的 O(n²) 时间复杂度，可以采用以下优化策略：

- **随机选择基准**：随机选择数组中的一个元素作为基准，而不是总是使用第一个或最后一个元素。
- **三数取中法**：取数组头、尾、中间三个元素的中位数作为基准值。
- **小数组切换插入排序**：当子数组规模较小（如长度小于10）时，递归开销相对较大，可转而使用插入排序。

### 💎 总结

快速排序因其**平均时间复杂度低**（O(n log n)）和**原地排序**的特性（空间复杂度 O(log n)），在实践中有广泛应用，尤其适合处理**大数据量**的排序任务。但其**最坏情况性能**（O(n²)）和**不稳定性**是需要留意的方面。通过随机选择基准等优化方法，可有效降低最坏情况发生的概率。