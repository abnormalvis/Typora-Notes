[数据结构与算法专栏 —— C++实现](https://blog.csdn.net/Newin2020/article/details/126445229)

> 写在前面：  
> 今天我们来学习一下栈结构，栈在C++的STL中同样可以直接调用，但是我们可以用C++自己实现栈的结构。

## 栈的定义

栈满足“先进后出”的原则，也就是说只能从尾部插入和删除，而栈的实现可以通过数组和链表两种方法实现，我们一般常用数组来进行模拟，下面的讲解都以数组的实现进行。  
实现栈的结构需要存储数据的地方和一个指向栈顶的指针，而用数组实现的话指针一开始的位置就在下标 0 或 -1 ，我一般习惯初始化指针在下标为 -1 的位置。

```cpp
struct Stack {
	int Sacklist[MAXVERTIES] = { 0 };	//初始化栈中元素
	int top = -1;	//初始化指针位置
};
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f1c461d491301675096f56043522c3d9.png)

## 栈的插入

当我们不断往这个栈中放入数据时，指针下标也会不断的增加。  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1f206aac94ed36faa6b07beda59f7df1.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5706dce24b348bac43d7cc0a1a39adf2.png)

```cpp
void Push(Stack& S, int key) {
	if (S.top == MAXVERTIES-1) {
		cout << "栈已满！" << endl;
		return;
	}
	++S.top;
	S.Sacklist[S.top] = key;
}
```

## 栈的删除

当你想要删除或取出栈中元素时，你只能从最顶端的元素开始取，这个过程中指针的下标又会减小。  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0f7b2d4ae06e9c8f20d02f4be89b156e.png)  
但是这里需要注意的是，删除或取出数组中的元素并不会随之消失，只是指针在变动，下次插入数据时就会覆盖之前的内容。

```cpp
//删除栈顶元素
void Pop(Stack& S) {
	if (S.top == -1) {
		cout << "栈为空！" << endl;
		return;
	}
	int temp = S.Sacklist[S.top];
	--S.top;
}
```

## 返回栈顶元素

```cpp
//返回栈顶元素
int top(Stack& S) {
	return S.Sacklist[S.top];
}
```

## 查找栈中元素

```cpp
//判断栈中的元素是否存在(存在则返回对应下标，不存在则返回0)
int find(Stack& S, int key) {
	if (S.top == -1) {
		cout << "栈为空!" << endl;
		return -1;
	}
	//定义一个临时指针指向栈顶
	for (int temp = S.top; temp != -1; --temp) {
		if (S.Sacklist[temp] == key)
			return temp;
	}
	cout << "查无此元素！" << endl;
	return 0;
}
```

## 删除指定元素

这个地方要注意的是，我们想要删除栈中任意一处元素时，需要先把删除元素上面的所有元素出栈，并将出栈元素用一个临时栈来储存，然后将该元素删除，再把刚刚出栈的元素入栈。  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/99e2b697d7e8baf38921a143af387af6.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f33ef152d53ed6afd7a361587f172497.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e55f18cb74a1471906da3d1030149dd5.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/61c35e17ea72b05fec817d122466ca1b.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a2d2ab7357a3e4e470c7f5e2f1905f62.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ae1c3a253a98f3edb1b9716b1e3de1d3.png)

```cpp
//删除指定元素
void delete_index(Stack& S, int key) {
	Stack temp;	//需要一个临时的栈去接收原始栈倒出来的元素
	int index = find(S, key);	//查找此元素
	if (index <= 0)
		return;
	while (S.top != index) {
		Push(temp, S.Sacklist[S.top]);
		Pop(S);
	}
	Pop(S);	//删除指定元素
	while (temp.top != -1) {
		S.Sacklist[++S.top] = temp.Sacklist[temp.top];	//将临时栈中的元素再倒回去
		--temp.top;
	}
}
```

## 遍历栈

```cpp
//遍历整个栈
void show(Stack& S) {
	if (S.top == -1)
		cout << "栈为空！" << endl;
	int temp = S.top;	//定义一个临时指针
	while (temp != -1) {
		cout << S.Sacklist[temp] << " ";
		--temp;
	}
	cout << endl;
}
```

## 全部代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXVERTIES 20

//栈的结构体
struct Stack {
	int Sacklist[MAXVERTIES] = { 0 };	//初始化栈中元素
	int top = -1;	//初始化指针位置
};

//往栈中推入元素
void Push(Stack& S, int key) {
	if (S.top == MAXVERTIES-1) {
		cout << "栈已满！" << endl;
		return;
	}
	++S.top;
	S.Sacklist[S.top] = key;
}

//删除栈顶元素
void Pop(Stack& S) {
	if (S.top == -1) {
		cout << "栈为空！" << endl;
		return;
	}
	int temp = S.Sacklist[S.top];
	--S.top;
}

//返回栈顶元素
int top(Stack& S) {
	return S.Sacklist[S.top];
}

//判断栈中的元素是否存在(存在则返回对应下标，不存在则返回0)
int find(Stack& S, int key) {
	if (S.top == -1) {
		cout << "栈为空!" << endl;
		return -1;
	}
	//定义一个临时指针指向栈顶
	for (int temp = S.top; temp != -1; --temp) {
		if (S.Sacklist[temp] == key)
			return temp;
	}
	cout << "查无此元素！" << endl;
	return 0;
}

//删除指定元素
void delete_index(Stack& S, int key) {
	Stack temp;	//需要一个临时的栈去接收原始栈倒出来的元素
	int index = find(S, key);	//查找此元素
	if (index <= 0)
		return;
	while (S.top != index) {
		Push(temp, S.Sacklist[S.top]);
		Pop(S);
	}
	Pop(S);	//删除指定元素
	while (temp.top != -1) {
		S.Sacklist[++S.top] = temp.Sacklist[temp.top];	//将临时栈中的元素再倒回去
		--temp.top;
	}
}

//遍历整个栈
void show(Stack& S) {
	if (S.top == -1)
		cout << "栈为空！" << endl;
	int temp = S.top;	//定义一个临时指针
	while (temp != -1) {
		cout << S.Sacklist[temp] << " ";
		--temp;
	}
	cout << endl;
}

int main() {
	Stack S;
	Push(S, 1);
	Push(S, 8);
	Push(S, 5);
	Push(S, 4);
	Push(S, 2);
	show(S);
	Pop(S);
	show(S);
	delete_index(S, 2);
	delete_index(S, 5);
	show(S);
}
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cf87ae6eefcb5c1280f7b509a2877e4d.png)  
如果大家有什么问题的话，欢迎在下方评论区进行讨论哦~

[【上一讲】线性表 - 03 双向循环链表](https://blog.csdn.net/Newin2020/article/details/123189738)  
[【下一讲】线性表 - 05 队列（数组实现）](https://blog.csdn.net/Newin2020/article/details/123722941)