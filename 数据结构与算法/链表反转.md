链表反转是 C++ 中一个经典且重要的算法问题，通常使用迭代或递归方法实现。下面我将为你解释这两种方法的原理、代码实现，并提供一些对比和注意事项。

# 🔄 C++ 链表反转详解

## 1️⃣ 基本概念：什么是链表反转

链表反转是指将一条单链表的所有节点指向逆序。例如，原链表为 `1 → 2 → 3 → 4 → 5 → NULL`，反转后应变为 `5 → 4 → 3 → 2 → 1 → NULL`。反转操作需要改变每个节点的 `next`指针指向，使其指向前一个节点而非后一个节点。

## 2️⃣ 节点定义

在 C++ 中，链表节点通常定义为结构体（struct），包含值（val）和指向下一个节点的指针（next）。常见定义如下：

```
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

## 3️⃣ 迭代法实现

迭代法通过循环遍历链表，逐个调整节点指针指向，是反转链表最常用且效率较高的方法。

### 算法步骤

1. **初始化三个指针**： `prev`：指向当前节点的前一个节点（初始为 `nullptr`）。 `curr`：指向当前正在处理的节点（初始为 `head`）。 `nextTemp`：临时保存当前节点的下一个节点（防止链表断裂）。
2. **遍历链表**： 在循环中，先保存 `curr->next`到 `nextTemp`。 将 `curr->next`指向 `prev`，实现反转。 将 `prev`和 `curr`指针分别向后移动一位。
3. **终止条件**：当 `curr`为 `nullptr`时，遍历结束，此时 `prev`指向新的头节点。

### 代码示例

```
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    while (curr != nullptr) {
        ListNode* nextTemp = curr->next; // 保存下一个节点
        curr->next = prev;                // 反转指针
        prev = curr;                      // 移动prev
        curr = nextTemp;                  // 移动curr
    }
    return prev; // 返回新头节点
}
```

### 执行过程示例

以链表 `1 → 2 → 3 → 4 → 5 → NULL`为例，其反转过程如下：

| 循环次数 | prev (指向) | curr (指向) | nextTemp (保存) | 链表状态 (反转部分)          |
| -------- | ----------- | ----------- | --------------- | ---------------------------- |
| 初始     | nullptr     | 1           | -               | 1 → 2 → 3 → 4 → 5 → NULL     |
| 第1次    | 1           | 2           | 2               | **NULL ← 1**                 |
| 第2次    | 2           | 3           | 3               | **NULL ← 1 ← 2**             |
| 第3次    | 3           | 4           | 4               | **NULL ← 1 ← 2 ← 3**         |
| 第4次    | 4           | 5           | 5               | **NULL ← 1 ← 2 ← 3 ← 4**     |
| 第5次    | 5           | nullptr     | -               | **NULL ← 1 ← 2 ← 3 ← 4 ← 5** |

最终 `prev`指向节点 5，成为新链表的头。

## 4️⃣ 递归法实现

递归法从链表尾部开始反转，思路巧妙但空间复杂度较高。

### 算法思路

1. **递归基**：如果链表为空或只有一个节点，直接返回头节点。
2. **递归步骤**： 递归调用 `reverseList(head->next)`，反转以 `head->next`为首的剩余子链表。 此时，`head->next`实际上已指向反转后子链表的尾节点。 将 `head->next`（子链表尾节点）的 `next`指针指向当前节点 `head`。 将当前节点 `head`的 `next`指针置为 `nullptr`，防止成环。

### 代码示例

```
ListNode* reverseList(ListNode* head) {
    // 递归终止条件：空链表或只有一个节点
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    // 递归反转剩余链表，p指向反转后的新头节点
    ListNode* p = reverseList(head->next);
    // 将当前节点接到反转后链表的尾部
    head->next->next = head;
    head->next = nullptr; // 防止形成环
    return p; // 返回新的头节点
}
```

### 递归过程简要说明

递归会一直深入到链表尾部。对于链表 `1 → 2 → 3 → 4 → 5`：

1. 递归到节点 5 时，因 `5->next`为 `nullptr`，返回节点 5 作为新头。
2. 退回至节点 4：`4->next->next`(即 `5->next`) 指向 4，`4->next`置 `nullptr`。此时链表状态为 `5 → 4`。
3. 退回至节点 3：`3->next->next`(即 `4->next`) 指向 3，`3->next`置 `nullptr`。链表变为 `5 → 4 → 3`。
4. 依此类推，直至完全反转。

## 5️⃣ 方法对比与选择

| 特性           | 迭代法                                   | 递归法                       |
| -------------- | ---------------------------------------- | ---------------------------- |
| **时间复杂度** | O(n)                                     | O(n)                         |
| **空间复杂度** | O(1)                                     | O(n) (递归栈空间)            |
| **优点**       | 效率高，空间占用少                       | 代码简洁，逻辑清晰           |
| **缺点**       | 代码相对递归稍多                         | 链表较长时可能栈溢出         |
| **适用场景**   | 一般首选，尤其适用于长链表或内存受限环境 | 链表长度可控，追求代码简洁性 |

**选择建议**：在实际开发或面试中，**迭代法通常是更安全且被优先推荐的选择**，因为它没有栈溢出的风险，且空间效率更优。递归法虽然代码简洁，但需要注意递归深度问题。

## 6️⃣ 注意事项

- **空链表处理**：若输入头节点 `head`为 `nullptr`，直接返回 `nullptr`。
- **单节点链表**：反转后仍是自身，迭代和递归都能正确处理。
- **指针操作顺序**：在迭代法中，务必**先保存下一个节点**（`nextTemp = curr->next`），再反转指针，否则会丢失后续节点。
- **内存管理**：在 C++ 中，如果原链表节点是动态分配的，反转操作本身不会销毁或释放节点。若原链表不再需要，应注意在适当的时候释放其内存，防止泄漏。不过，反转函数通常只负责调整指针指向，内存管理由调用者负责。

掌握链表反转有助于深化对指针操作和递归思想的理解，这也是许多算法问题的基础。希望这些解释和代码示例能帮助你更好地理解和实现它。