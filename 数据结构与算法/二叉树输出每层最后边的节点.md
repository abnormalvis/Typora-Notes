我来为你提供一个输出二叉树每一层最右边节点的C++解决方案。

## 方法一：BFS层序遍历（推荐）

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        if (!root) return result;
        
        queue<TreeNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            int levelSize = q.size();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode* node = q.front();
                q.pop();
                
                // 如果是当前层的最后一个节点（最右边的节点）
                if (i == levelSize - 1) {
                    result.push_back(node->val);
                }
                
                // 将左右子节点加入队列
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        
        return result;
    }
};

// 辅助函数：创建测试用例
TreeNode* createTestTree() {
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->right = new TreeNode(5);
    root->right->right = new TreeNode(4);
    return root;
}

// 打印结果
void printResult(const vector<int>& result) {
    cout << "每一层最右边的节点: ";
    for (int val : result) {
        cout << val << " ";
    }
    cout << endl;
}

int main() {
    Solution solution;
    TreeNode* root = createTestTree();
    
    vector<int> result = solution.rightSideView(root);
    printResult(result);
    
    return 0;
}
```

## 方法二：DFS递归解法

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class SolutionDFS {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        dfs(root, 0, result);
        return result;
    }
    
private:
    void dfs(TreeNode* node, int depth, vector<int>& result) {
        if (!node) return;
        
        // 如果当前深度等于结果数组的大小，说明这是该层第一个被访问的节点
        // 由于我们先访问右子树，所以这个节点就是最右边的节点
        if (depth == result.size()) {
            result.push_back(node->val);
        }
        
        // 先递归右子树，再递归左子树
        dfs(node->right, depth + 1, result);
        dfs(node->left, depth + 1, result);
    }
};
```

## 方法三：带层次信息的BFS

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class SolutionDetailed {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        if (!root) return result;
        
        queue<pair<TreeNode*, int>> q; // 存储节点和其深度
        q.push({root, 0});
        
        int currentDepth = -1;
        
        while (!q.empty()) {
            auto [node, depth] = q.front();
            q.pop();
            
            // 如果是新的一层，记录当前节点（最右边的节点）
            if (depth > currentDepth) {
                result.push_back(node->val);
                currentDepth = depth;
            }
            
            // 注意：先右后左，这样每层第一个访问的就是最右边的节点
            if (node->right) q.push({node->right, depth + 1});
            if (node->left) q.push({node->left, depth + 1});
        }
        
        return result;
    }
};
```

## 完整测试代码

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// BFS解法
vector<int> rightSideViewBFS(TreeNode* root) {
    vector<int> result;
    if (!root) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        TreeNode* rightmost = nullptr;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            // 记录当前节点
            rightmost = node;
            
            // 将左右子节点加入队列
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        // 将当前层最右边的节点加入结果
        if (rightmost) {
            result.push_back(rightmost->val);
        }
    }
    
    return result;
}

// 创建不同的测试树
TreeNode* createTree1() {
    //     1
    //    / \
    //   2   3
    //    \   \
    //     5   4
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->right = new TreeNode(5);
    root->right->right = new TreeNode(4);
    return root;
}

TreeNode* createTree2() {
    //     1
    //    / \
    //   2   3
    //  /   / \
    // 4   5   6
    //    /
    //   7
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->right->left = new TreeNode(5);
    root->right->right = new TreeNode(6);
    root->right->left->left = new TreeNode(7);
    return root;
}

void printResult(const vector<int>& result, const string& treeName) {
    cout << treeName << " 的右视图: ";
    for (int val : result) {
        cout << val << " ";
    }
    cout << endl;
}

int main() {
    // 测试树1
    TreeNode* tree1 = createTree1();
    vector<int> result1 = rightSideViewBFS(tree1);
    printResult(result1, "树1");
    
    // 测试树2
    TreeNode* tree2 = createTree2();
    vector<int> result2 = rightSideViewBFS(tree2);
    printResult(result2, "树2");
    
    return 0;
}
```

## 输出示例

对于测试树1：
```
     1
    / \
   2   3
    \   \
     5   4
```
输出：`1 3 4`

对于测试树2：
```
     1
    / \
   2   3
  /   / \
 4   5   6
    /
   7
```
输出：`1 3 6 7`

## 算法复杂度分析

- **时间复杂度**：O(n)，其中n是树中的节点数，每个节点只被访问一次
- **空间复杂度**：O(w)，其中w是树的最大宽度，即队列的最大长度

**推荐使用方法一的BFS解法**，因为它思路清晰，代码简洁，且易于理解和维护。