智能计算及其应用
========

进化算法
----

### 进化算法的概念

进化算法(evolutionary algorithms，EA)是基于自然选择和自然遗传等生物进化机制的一种搜索算法。进化算法是一个“算法簇” ，包括`遗传算法(GA)`、`遗传规划`和`进化规划`等。进化算法的基本框架是遗传算法所描述的框架。进化算法可广泛应用于组合优化、机器学习、自适应控制、规划设计和人工生命等领域。

### 进化算法的生物学背景

`适者生存`：最适合自然环境的群体往往产生了更大的后代群体。生物进化的基本过程如下图：

![005](https://img2022.cnblogs.com/blog/2258925/202204/2258925-20220406171852183-913617327.png)

*   染色体(chromosome)：生物遗传物质的主要载体。
*   基因(gene)：扩展生物性状的遗传物质的功能单元和结构单位。
*   基因座（locus）：染色体中基因的位置。
*   等位基因（alleles）：基因所取的值

### 进化算法的设计原则

*   `适用性`原则：一个算法的适用性是指该算法所能适用的问题种类，它取决于算法所需的限制与假定。优化问题的不同，则相应的处理方式也不同。
*   `可靠性`原则：一个算法的可靠性是指算法对于所设计的问题，以适当的精度求解其中大多数问题的能力。因为演化计算的结果带有一定的随机性和不确定性，所以，在设计算法时应尽量经过较大样本的检验，以确认算法是否具有较大的可靠度。
*   `收敛性`原则：指算法能否收敛到全局最优。在收敛的前提下，希望算法具有较快的收敛速度。
*   `稳定性`原则：指算法对其控制参数及问题的数据的敏感度。如果算法对其控制参数或问题的数据十分敏感，则依据它们取值的不同，将可能产生不同的结果，甚至过早地收敛到某一局部最优解。所以，在设计算法时应尽量使得算法对一组固定的控制参数能在较广泛的问题的数据范围内解题，而且对一组给定的问题数据，算法对其控制参数的微小扰动不很敏感。
*   `生物类比`原则：因为进化算法的设计思想是基于生物演化过程的，所以那些在生物界被认为是有效的方法及操作可以通过类比的方法引人到算法中，有时会带来较好的结果。

遗传算法
----

### 遗传算法的基本思想

在求解问题时从多个解开始，然后通过一定的法则进行逐步迭代以产生新的解。

| 生物遗传学概念 | 遗传算法之应用 |
| --- | --- |
| 适者生存 | 目标值比较大的解被选择的可能性大 |
| 个体（Individual） | 解 |
| 染色体（Chromosome） | 解的编码（字符串、向量等） |
| 基因（Gene） | 解的编码中每一分量 |
| 适应性（Fitness） | 适应度函数值 |
| 群体（Population） | 根据适应度值选定的一组解（解的个数 为群体的规模） |
| 婚配（Marry） | 交叉（Crossover）选择两个染色体进行 交叉产生一组新的染色体的过程 |
| 变异（Mutation） | 编码的某一分量发生变化的过程 |

### 遗传算法的发展历史

*   1962年，Fraser提出了自然遗传算法。
*   1965年，Holland首次提出了人工遗传操作的重要性。
*   1967年，Bagley首次提出了遗传算法这一术语。
*   1970年，Cavicchio把遗传算法应用于模式识别中。
*   1971年，Hollstien在论文《计算机控制系统中人工遗传 自适应方法》中阐述了遗传算法用于数字反馈控制的 方法。
*   1975年，美国J. Holland出版了《自然系统和人工系统 的适配》；DeJong完成了重要论文《遗传自适应系统 的行为分析》。
*   20世纪80年代以后，遗传算法进入兴盛发展时期。

### 编码

由于遗传算法不能直接处理问题空间的参数，因此必须通过编码将要求解的问题表示成遗传空间的染色体或者个体。对一个具体问题如何进行编码是应用遗传算法的首要问题，也是其难点。

*   `位串编码`：将问题空间的参数编码为一维排列的染色体的方法被称为一维染色体编码方法。其中最常用的就是二进制编码
    
    *   `二进制编码`：用若干二进制数表示一个个体，将原问题 的解空间映射到位串空间\\(B=\\{0,1\\}\\)上，然后在位串空间上进行遗传操作。
        
        *   优点：类似于生物染色体的组成，算法易于用生物遗传理论解释，遗传操作如交叉、变异等易实现；算法处理的模式数最多。
        *   缺点：
            1.  相邻整数的二进制编码可能具有较大的Hamming距离，降低 了遗传算子的搜索效率。
            2.  要先给出求解的精度。
            3.  求解高维优化问题的二进制编码串长，算法的搜索效率低。
    *   `Gray 编码`：将二进制编码通过一个变换进行转换得到的编码。设二进制串\\(<\\beta\_1\\beta\_2\\cdots\\beta\_n>\\)对应Gray 串\\(<\\gamma\_1\\gamma\_2\\cdots\\gamma\_n>\\)，则从二进制编码到Gray 编码的变换为：
        
        \\\[\\begin{equation} \\gamma\_k=\\left\\{ \\begin{aligned} & \\beta\_1 & k=0 \\\\ & \\beta\_{k-1}\\oplus\\beta\_k & k>1 \\end{aligned} \\right. \\end{equation} \\\]
        
        式中\\(\\oplus\\)表示模 2 加法，从一个Gray串到二进制串的变换为：
        
        \\\[\\begin{equation} \\beta\_k=\\sum^k\_{i=1}\\gamma\_i(mod\\ 2)=\\left\\{ \\begin{aligned} & \\gamma\_1 & k=1 \\\\ & \\beta\_{k-1}\\oplus\\gamma\_k & k>1 \\end{aligned} \\right. \\end{equation} \\\]
        
        Gray 编码克服了二进制编码的Hamming悬崖的缺点。
        
*   `实数编码`：用若干使署表示一个个体，然后在实数空间上进行遗传操作。采用实数表达法不必进行数制转换，可直接在解的表现型上进行遗传操作。
    
*   `多参数级联编码`：把每个参数先进行二进 制编码得到子串，再把这些子串连成一个完整的染色体。多参数级联编码中的每个子串对应各自的编码参数， 所以可以有不同的串长度和参数的取值范围。
    

### 群体设定

群体设定主要包括初始种群的产生和种群规模的确定：

*   初始群体的产生
    *   根据问题固有知识，把握最优解所占空间在整个问题空间中的分布范围，然后在此分布范围内设定初始群体。
    *   随机产生一定数目的个体，从中挑选最好的个 体加到初始群体中。这种过程不断迭代，直到初始群体中个体数目达到了预先确定的规模。
*   种群规模的确定
    *   群体规模太小，遗传算法的优化性能不太好，易陷入局部最优解。
    *   群体规模太大，计算复杂。
    *   种群规模一般取20-100.

### 适应度函数

适应度是评价个体优劣的标准。适应度函数是用来区分群体中个体好坏的标准，一般而言适应度函数是由目标函数变换得到的。

*   将目标函数映射成适应度函数的方法
    
    *   若目标函数为最大化问题，则\\(Fit(f(x))=f(x)\\)
    *   若目标函数为最小化问题，则$Fit(f(x))=\\frac{1}{f(x)} $
*   适应度函数的尺度变换：在遗传算法中，将所有妨碍适应度值高的个体产生，从 而影响遗传算法正常工作的问题统称为`欺骗问题 （deceptive problem）`。如果出现`过早收敛`则需要缩小这些个体的适应度，以降低这些超级个 体的竞争力。如果`停滞现象`则需要改变原始适应值的比例关系，以提高个体之 间的竞争力。对适应度函数值域的某种映射变换即为适应度函数的`尺度变换（fitness scaling）或者定标`。
    
    *   线性变换
        
        \\\[f'=af+b\\\\满足{f'}\_{avg}=f\_{avg}\\ ,\\ {f'}\_{max}=C\_{mult}\\cdot f\_{avg}\\\\ \\\\ 其中a=\\frac{(C\_{mult}-1)f\_{avg}}{f\_{max}-f\_{avg}}\\qquad b=\\frac{(f\_{max}-C\_{mult}f\_{avg})f\_{avg}}{f\_{max}-f\_{avg}} \\\]
        
    *   幂函数变换法
        
        \\\[f'=f^K \\\]
        
        式中幂指数 \\(K\\) 与求解问题有关，且在算法过程中可按需修正。
        
    *   指数函数变换法
        
        \\\[f'=e^{-af} \\\]
        
        式中 \\(a\\) 决定了复制的强制性，其值越小复制的强制性就越趋于那些具有最大适应度的个体。
        

### 选择

选择操作也称为复制（reproduction）操作：从当前群体中按照一定概率选出优良的个体，使它们有机会作为父代繁殖下一代子孙。判断个体优良与否的准则是各个个体的适应度值，即个体适应度越高，其被选择的机会就越多。

如果总挑选最好的，则遗传算法就变成了确定优化方法，使种群过快收敛到局部最优解。如果只做随机选择，则遗传算法就变成完全随机方法，需要很长时间才收敛。介绍以下几种常见选择方法：

*   个体选择概率分配
    
    *   `适应度比例方法`：各个个体被选择的概率和其适应度值成比例。设群体规模大小为 \\(M\\)，个体 \\(i\\) 的适应度值为 \\(f\_i\\)，则这个个体被选择的概率为
        
        \\\[p\_{si}=\\frac{f\_i}{\\sum\\limits^k\_{i=1}f\_i} \\\]
        
    *   `排序方法`：对每个个体按适应度大小顺序对群体中个体进行排序，然后把事先设计好的概率按排序分配给个体作为其选择概率。概率仅取决于个体在种群中的序位，排在前面的个体有较多的被选择的机会。常用以下排序方法：
        
        *   线性排序：群体成员按适应值大小从好到坏依次排列并按下式分配选择概率
            
            \\\[p\_i=\\frac{a-bi}{M(M+1)} \\\]
            
            其中，\\(a,b\\) 是常数。然后按类似转盘式选择的方式选择父体进行遗传操作。
            
        *   非线性排序：群体成员按适应值大小从好到坏依次排列并按下式分配选择概率
            
            \\\[\\begin{equation} p\_i=\\left\\{ \\begin{aligned} & q(1-q)^{i-1} && i=1,2,\\cdots,M-1\\\\ & (1-q)^{M-1} && i=M \\end{aligned} \\right. \\end{equation} \\\]
            
*   选择个体方法
    
    *   轮盘赌选择：按个体的选择概率产生一个轮盘，轮盘每个区的角度与个体的选择概率成比例，然后产生一个随机数，它落入转盘的哪个区域就选择相应的个体交叉。
    *   锦标赛选择：从群体中随机选择 \\(k\\) 个个体，将其中适应 度最高的个体保存到下一代。这一过程反复执行，直到保存到下一代的个体数达到预先设定的数量为止。参数 \\(k\\) 称为竞赛规模。
    *   最佳个体保存方法：把群体中适应度最高的个体不进行交叉而直接复制到下一代中，保证遗传算法终止时得到的最后结果一定是历代出现过的最高适应度的个体。

### 交叉

当两个生物机体配对或者复制时，它们的染色体相互混合，产生一个由双方基因组成的全新的染色体组。这一过程称为重组（recombination）或者交叉（crossover）。遗传算法中起核心作用的是交叉算子，也称为基因重组（recombination）。采用的交叉方法应能够使父串的特征遗传给子串。子串应能够部分或者全部地继承父串的结构特征和有效基因。

*   基本交叉算子
    
    *   单点交叉：在个体串中随机设定一个交叉点，实行交叉时，该点前或后的两个个体的部分结构进行互换， 并生成两个新的个体。
    *   两点交叉：随机设置两个交叉点，将两个交叉点之间的码串相互交换。
    *   均匀交叉：按照均匀概率抽取一些位，每一位是否被选取都是随机的，并且独立于其他位。然后将两个个体被抽取位互换组成两个新个体。
*   修正的交叉方式
    
    由于交叉可能出现不满足约束条件的非法染色体。为解决这一问题，可以采取构造惩罚函数的方法，但试验效果不佳，使得本已复杂的问题更加复杂。另一种处理方法是对交叉、变异等遗传操作作适当的修正，使其自动满足优化问题的约束条件。
    
    *   部分匹配交叉PMX：先依据均匀随机分布产生两个位串交叉点，定义这两点之间的区域为一匹配区域，并使用位置交换操作交换两个父串的匹配区域，再按照匹配区域内的位置映射关系进行交换，从而使排列成为可行调度。

### 变异

进化机制除了能够改进已有特征，也能够产生新的特征。在遗传算法中，变异是将个体编码中的一些位进行随机变化。变异的主要目的是维持群体的多样性，为选择、交叉过程中可能丢失的某些遗传基因进行修复和补充。变异算子的基本内容是对群体中的个体串的某些基因座上的基因值作变动。变异操作是按位进行的，即把某一位的内容进行变异。变异概率是在一个染色体中按位进行变化的概率。主要变异方法有以下5种。

*   位点变异：群体中的个体码串，随机挑选一个或多 个基因座，并对这些基因座的基因值以变异概率作变动。
*   逆转变异：在个体码串中随机选择两点（逆转点）， 然后将两点之间的基因值以逆向排序插入到原位置中。
*   插入变异：在个体码串中随机选择一个码，然后将 此码插入随机选择的插入点中间。
*   互换变异：随机选取染色体的两个基因进行简单互换。
*   移动变异：随机选取一个基因，向左或者向右移动一个随机位数。

为防止群体重要单一基因丢失，变异概率\\(P\_m\\)通常设置为0.001左右。

### 遗传算法的一般步骤

![006](https://img2022.cnblogs.com/blog/2258925/202204/2258925-20220406171859473-2085871987.png)

1.  使用随机方法或者其它方法，产生一个有 \\(N\\)​ 个染色体的初始群体
    
    \\\[pop(1),\\ t:=1 \\\]
    
2.  对群体中的每一个染色体 \\(pop\_i(t)\\)​，计算其适应值
    
    \\\[f\_i=fitness(pop\_i(t)) \\\]
    
3.  若满足停止条件，则算法停止；否则，以概率 \\(p\_i=f\_i/\\sum\\limits^N\_{j=1}f\_j\\) 从 \\(pop(t)\\)​中随机选择一些染色体构成一个新种群
    
    \\\[newpop(t+1)=\\{pop\_j(t)\\mid j=1,2,\\cdots,N \\} \\\]
    
4.  以概率 \\(p\_c\\)​ 进行交叉产生一些新的染色体，得到一个新的群体
    
    \\\[crosspop(t+1) \\\]
    
5.  以一个较小的概率 \\(p\_m\\)使染色体的一个基因发生变异， 形成 \\(mutpop(t+1);t:=t+1\\)​ ，成为一个新的群体
    
    \\\[pop(t)=mutpop(t+1) \\\]
    
    返回 2。
    

### 遗传算法的特点

*   可直接对结构对象进行操作。
*   利用随机技术指导对一个被编码的参数空间进行高效率搜索。
*   采用群体搜索策略，易于并行化。
*   仅用适应度函数值来评估个体，并在此基础上进行遗传操作，使种群中个体之间进行信息交换。

### 遗传算法的改进

#### 双倍体遗传算法

*   基本思想：双倍体遗传算法采用显性和隐性两个染色体同时进行进化，提供了一种记忆以前有用的基因块的功能。双倍体遗传算法采用显性遗传，延长了有用基因块的寿命，提高了算法的收敛 能力，在变异概率低的情况下能保持一定水平的多样性。
    
*   双倍体遗传算法的设计
    
    1.  编码/解码：两个染色体（显性、隐性）
    2.  复制算子：计算显性染色体的适应度，按照显性染色体的复制概率将个体复制到下一代群体中。
    3.  交叉算子：两个个体的显性染色体交叉、隐性染色体也同时交叉。
    4.  变异算子：个体的显性染色体按正常的变异概率变异； 隐性染色体按较大的变异概率变异。
    5.  双倍体遗传算法显隐性重排算子：个体中适应值较大的染色体设为显性染色体，适应值较小的染色体设为隐性染色体。
*   基本流程：
    
    ![007](https://img2022.cnblogs.com/blog/2258925/202204/2258925-20220406171901936-1182278207.png)

#### 双种群遗传算法

*   基本思想：在遗传算法中使用多种群同时进化，并交换种群之间优秀个体所携带的遗传信息，以打破种群内的平衡态达到更高的平衡态，有利于算法跳出局部最优。
    
*   双种群遗传算法的设计：
    
    1.  编码/解码设计
    2.  交叉算子、变异算子
    3.  杂交算子：设种群A与种群B，当A与B种群都完成了选择、交叉、 变异算子后，产生一个随机数num，随机选择A中num个个体与A中最优个体，随机选择B中num个个体与B中最 优个体，交换两者，以打破平衡态。
*   基本流程：
    
    ![008](https://img2022.cnblogs.com/blog/2258925/202204/2258925-20220406171904095-2088518831.png)

#### 自适应遗传算法

*   基本思想：使交叉概率\\(P\_c\\)和变异概率\\(P\_m\\)能够随适应度变化自动改变。当种群各个体适应度趋于一致或者趋于局部最优时，使\\(P\_c\\)和\\(P\_m\\)增加，以跳出局部最优；而当群体适应度比较分散时，使\\(P\_c\\)和\\(P\_m\\)减少，以利于优良个体的生存。同时，对于适应度高于群体平均适应值的个体，选择较低的\\(P\_c\\)和\\(P\_m\\)，使得该解得以保护进入下一代；对低于平均适应值的个体，选择较高的\\(P\_c\\)和\\(P\_m\\)，使该解被淘汰。
    
*   自适应遗传算法的步骤：
    
    1.  编码/解码设计。
    2.  初始种群产生：\\(N\\)（\\(N\\)是偶数）个候选解，组成初始解集。
    3.  定义适应度函数为\\(f=1/ob\\)，计算适应度 \\(f\_i\\)。
    4.  按轮盘赌规则选择\\(N\\)个个体，计算 \\(f\_{avg}\\)和\\(f\_{max}\\)。
    5.  将群体中的各个个体随机搭配成对，共组成\\(N/2\\)对， 对每一对个体，按照自适应公式计算自适应交叉概率 \\(P\_c\\)， 随机产生\\(R(0,1)\\)，如果\\(R<P\_c\\)则对该对染色体进行交叉操作。
    6.  对于群体中的所有个体，共\\(N\\)个，按照自适应变异公式计算自适应变异概率 ，随机产生\\(R(0,1)\\)，如果\\(R<P\_m\\)则对该染色体进行交叉操作。
    7.  计算由交叉和变异生成新个体的适应度，新个体与父代一起构成新群体。
    8.  判断是否达到预定的迭代次数，是则结束；否则转 4。
*   自适应的交叉概率与变异概率：\\(P\_c\\)和\\(P\_m\\)按照以下公式进行调整
    
    \\\[\\begin{equation} p\_c=\\left\\{ \\begin{aligned} & \\frac{k\_1(f\_{max}-f')}{f\_{max}-f\_{avg}} && f'>f\_{avg}\\\\ & k\_2 && f'\\le f\_{avg} \\end{aligned} \\right. \\end{equation} \\\]
    
    \\\[\\begin{equation} p\_m=\\left\\{ \\begin{aligned} & \\frac{k\_3(f\_{max}-f')}{f\_{max}-f\_{avg}} && f'>f\_{avg}\\\\ & k\_4 && f'\\le f\_{avg} \\end{aligned} \\right. \\end{equation} \\\]
    
    式中 \\(f\_{max}\\)是群体中最大的适应度值；\\(f\_{avg}\\)是每代群体的平均适应度值；\\(f'\\)是要交叉的两个个体中较大的适应度值；\\(f\\)是要变异的个体的适应度值。\\(k\_1,\\ k\_2,\\ k\_3,\\ k\_4\\) 是\\((0,\\ 1)\\)之间的常数。
    

### 遗传算法的应用

群智能算法产生的背景
----------

由简单个体组成的群落与环境以及个体之间的互动行为称为群体智能。群智能算法（swarm algorithms，SI）是受动物群体智能启发的算法。群智能算法包括：粒子群优化算法、蚁群算法、蜂群算法等。

![009](https://img2022.cnblogs.com/blog/2258925/202204/2258925-20220406171907069-2092545569.png)

粒子群优化算法
-------

### 粒子群优化算法的基本原理

粒子群优化（Particle Swarm Optimization, PSO）算法的基本概念源于对鸟群觅食行为的研究。其基本思想是将每个个体看作n维搜索空间中一个没有体积质量的粒子，在 搜索空间中以一定的速度飞行，该速度决定粒子飞行的方向和距离。所有粒子还有一个由被优化的函数决定的适应值。PSO初始化为一群随机粒子，然后通过迭代找到最优解。在每 一次迭代中，粒子通过跟踪两个“极值”来更新自己。第一个就是粒子本身所找到的最优解，这个解称为个体极值。另个一是整个种群目前找到的最优解，这个解称为全局极值。

*   算法定义：在 n 维连续搜索空间中，对粒子群中的第 \\(i(i=1,2,\\cdots,m)\\) 个粒子，定义
    
    *   n 维当前位置向量 \\(x^i(k)=\[x^i\_1,x^i\_2,\\cdots,x^i\_n\]^T\\) ：表示搜索空间中粒子的当前位置。
    *   n 维最优位置向量 \\(p^i(k)=\[p^i\_1,p^i\_2,\\cdots,p^i\_n\]^T\\) 表示该粒子至今所获得的具有最优适应度 \\(f^i\_p(k)\\)的位置。
    *   n 维速度位置向量 \\(v^i(k)=\[v^i\_1,v^i\_2,\\cdots,v^i\_n\]^T\\) 表示该粒子的搜索方向。
    
    每个粒子经历过的最优位置（pbest）记为 \\(p^i(k)=\[p^i\_1\\quad p^i\_2\\cdots p^i\_n\]\\)， 群体经历过的最优位置(gbest)记为 \\(p^g(k)=\[p^g\_1\\quad p^g\_2\\cdots p ^g\_n\]\\)，则基本的PSO算法为：
    
    \\\[v^i\_j(k+1)=\\omega(k)v^i\_j(k)+\\varphi\_1\\ rand(0,a\_1)(p^i\_j(k)-x^i\_j(k))+\\varphi\_2\\ rand(0,a\_2)(p^g\_j(k)-x^i\_j(k))\\\\ \\\\x^i\_j(k+1)=x^i\_j(k)+v^i\_j(k+1)\\qquad i=1,2,\\cdots,m;\\ j=1,2,\\cdots,n \\\]
    
    其中 \\(\\omega\\) 是惯性权重因子。\\(\\varphi\_1、\\varphi\_2\\) 是加速度常数，均为非负值。\\(rand(0,a\_1)\\) 和 \\(rand(0,a\_2)\\) 为 \\(\[0,a\_1\]、\[0,a\_2\]\\) 范围内的具有均匀分布的随机数，\\(a\_1\\) 和 \\(a\_2\\)为相应的控制参数。
    
    上述等式等号右侧：
    
    *   第一部分是粒子在前一时刻的速度；
    *   第二部分为个体“认知”分量，表示粒子本身的思考，将现有的位置和曾经经历过的最优解位置相比；
    *   第三部分是群体“社会”分量，表示粒子间的信息共享与相互合作；
    *   \\(\\varphi\_1、\\varphi\_2\\) 分别控制个体认知分量和社会分量相对贡献的学习率；
    *   \\(rand(0,a\_1)\\) 和 \\(rand(0,a\_2)\\) 增加认知和社会搜索方向的随机性和算法多样性。
*   基于学习率\\(\\varphi\_1、\\varphi\_2\\) ，Kennedy给出以下`4 种类型的PSO模型`：
    
    *   若 \\(\\varphi\_1>0,\\varphi\_2>0\\)，则称该算法为PSO全模型。
    *   若 \\(\\varphi\_1>0,\\varphi\_2=0\\)，则称该算法为PSO认知模型。
    *   若 \\(\\varphi\_1=0,\\varphi\_2>0\\)，则称该算法为PSO社会模型。
    *   若 \\(\\varphi\_1=0,\\varphi\_2>0且g\\ne i\\)，则称该算法为PSO无私模型。
*   粒子群优化算法的流程：
    
    1.  初始化每个粒子，即在允许范围内随机设置每个粒子的初始位置和速度。
        
    2.  评价每个粒子的适应度，计算每个粒子的目标函数。
        
    3.  设置每个粒子的 \\(p\_i\\)。对每个粒子，将其适应度与其经历过的最好位置 \\(p\_i\\) 进行比较，如果优于 \\(p\_i\\)，则将其作为该粒子的最好位置 \\(p\_i\\)。
        
    4.  设置全局最优值 \\(P\_g\\)。对每个粒子，将其适应度与群体经历过的最好位置 \\(P\_g\\) 进行比较，如果优于 \\(P\_g\\)，则将其作为当前群体的最好位置 \\(P\_g\\)。
        
    5.  根据上方公式更新粒子的速度和位置。
        
    6.  检查终止条件。如果未达到设定条件（预设误差或 者迭代的次数），则返回第 2 步。
        
        ![010](https://img2022.cnblogs.com/blog/2258925/202204/2258925-20220406171910195-1906019310.png)

### 粒子群优化算法的参数分析

*   PSO算法的参数
    
    *   最大速度 \\(V\_{max}\\)：对速度 \\(v\_i\\)，算法中有最大速度 \\(V\_{max}\\)作为限制，如果当前 粒子的某维速度大于最大速度\\(V\_{max}\\)，则该维的速度就被限制为最大速度\\(V\_{max}\\)。
    *   惯性权重 \\(\\omega\\)：粒子保持运动惯性，使其有扩展搜索空间的趋势，并有能力搜索新的区域。
    *   加速度 \\(\\varphi\_1,\\varphi\_2\\)：加速度常数 \\(\\varphi\_1,\\varphi\_2\\) 代表将每个粒子推向 \\(P\_i,P\_g\\) 位置的统计加速度项的权重。低的值允许粒子在被拉回之前可以在目标区域外徘徊，而高的值则导致粒子突然冲向或者越过目标区域。
*   位置更新方程中各部分的影响
    
    *   只有第1部分，即 \\(\\varphi\_1=\\varphi\_2=0\\)：粒子将一直以当前的速度飞行，直到达边界。 由于它只能搜索有限的区域，所以很难找到好解。
    *   没有第1部分，即 \\(\\omega=0\\)：速度只取决于粒子当前位置和其历史最好位置 \\(P\_i,P\_g\\)， 速度本身没有记忆性。
    *   没有第2部分，即 \\(\\varphi\_1=0\\)：粒子没有认知能力，也就是“只有社会模型” 。在粒子的相互作用下，有能力达到新的搜索空间。但对复杂问题，容易陷入局部最优点。
    *   没有第2部分，即 \\(\\varphi\_2=0\\)：粒子间没有社会共享信息，也就是“只有认知”模型。因为个体间没有交互，一个规模为M的群体等价于M个单个粒子的运行，因而得到最优解的机率非常小。
*   参数设置
    
    \\(\\omega\\) 固定为1.0， \\(\\varphi\_1,\\varphi\_2\\) 固定为2.0，因此 \\(V\_{max}\\) 成为唯一需要调节的参数，通常设为每维变化范 围10％~20%。Suganthan的实验表明， \\(\\varphi\_1,\\varphi\_2\\) 为常数时 可以得到较好的解，但不一定必须为2。这些参数也可以通过模糊系统进行调节。Shi和Eberhart 提出一个模糊系统来调节 \\(\\omega\\) 。
    

### 粒子群优化算法的应用领域

### 粒子群优化算法在车辆路径问题的应用

蚁群算法
----

20世纪90年代初，意大利科学家Marco Dorigo等受蚂蚁觅食行为的启发，提出蚁群算法(Ant Colony Optimization，ACO)。一种应用于组合优化问题的启发式搜索算法。在解决`离散`组合优化方面具有良好的性能。

*   信息素跟踪：按照一定的概率沿着信息素较强的路径觅食。
*   信息素遗留：会在走过的路上会释放信息素，使得在一定的范围内的其他蚂蚁能够觉察到并由此影响它们的行为。
*   环境：有障碍物、有其他蚂蚁、有信息素。
*   觅食规则：范围内寻找是否有食物，否则看是否有信息素，每只蚂蚁都会以小概率犯错。
*   移动规则：都朝信息素最多的方向移动，无信息素则继续朝原方向移动，且有随机的小的扰动，有记忆性。
*   避障规则：移动的方向如有障碍物挡住，蚂蚁会随机选择另一个方向。
*   信息素规则：越靠近食物播撒的信息素越多，越离开食物播撒的信息素越少。

### 基本蚁群算法模型

蚁群优化算法的第一个应用是著名的旅行商问题。

蚁群系统模型：

*   \\(m\\)：是蚁群中蚂蚁的数量
    
*   \\(d\_{xy}(x,y=1,···,n)\\)：表示元素(城市) 和元素(城市) 之间的距离。
    
*   \\(\\eta\_{xy}(t)\\)：表示能见度，称为启发信息函数，等于距离的倒数，即 \\(\\eta\_{xy}(t)=\\frac{1}{d\_{xy}}\\)。
    
*   \\(b\_x(t)\\)：表示 t 时刻位于城市x的蚂蚁的个数，\\(m=\\sum\\limits^n\_{x=1}b\_x(t)\\)。
    
*   \\(\\tau\_{xy}(t)\\)：表示 t 时刻在 xy 连线上残留的信息素，初始时刻，各条路径上的信息素相等即\\(\\tau\_{sy}(0)=C(const)\\)。蚂蚁k在运动过程中，根据各条路径上的信息素决定转移方向。
    
*   \\(P^k\_{xy}(t)\\)​：表示在 t 时刻蚂蚁 k 选择从元素(城市) x 转移到元素(城 市) y 的概率，也称为随机比例规则。由信息素和局部启发信息共同决定。
    
    \\\[\\begin{equation} P^k\_{xy}(t)=\\left\\{ \\begin{aligned} & \\frac{\\mid\\tau\_{xy}(t)\\mid^\\alpha\\mid\\eta\_{xy}(t)\\mid^\\beta}{\\sum\\limits\_{y\\in allowed\_k(x)}} && if\\quad y\\in allowed\_k(x)\\\\ & 0 && 其他 \\end{aligned} \\right. \\end{equation} \\\]
    
    *   \\(allowed\_k(x)=\\{0,1,···,n-1\\}-tabu\_k(x)=\\{c-tabu\_k(x)\\}\\)表示蚂蚁 k 下一步允许选择的城市。
    *   \\(tabu\_k(x)(k=1,2,···,m)\\)记录蚂蚁 k 当前所走过的城市。
    *   \\(\\alpha\\) 是信息素启发式因子，表示轨迹的相对重要性。
        *   \\(\\alpha\\) 值越大该蚂蚁越倾向于选择其它蚂蚁经过的路径，该状态转移概率越接近于贪婪规则。
        *   当\\(\\alpha=0\\) 时不再考虑信息素水平，算法就成为有多重起点的随机贪婪算法。
        *   当\\(\\beta=0\\) 时算法就成为纯粹的正反馈的启发式算法。
*   用参数 \\(1-\\rho\\) 表示信息素消逝程度，蚂蚁完成一次循环，各路径上信息素浓度消散规则为：\\(\\tau\_{xy}(t)=\\rho\\tau\_{xy}(t)+\\Delta\\tau\_{xy}(t)\\)，蚁群的信息素浓度更新规则为：\\(\\Delta\\tau\_{xy}(t)=\\sum\\limits^m\_{k=1}\\Delta\\tau^k\_{xy}(t)\\)。M. Dorigo给出 \\(\\Delta\\tau^k\_{xy}(t)\\)三种不同模型：
    
    *   蚂蚁圈系统（Ant-cycle System）：单只蚂蚁所访问路径上的信息素浓度更新规则为：
        
        \\\[\\begin{equation} \\Delta\\tau^k\_{xy}(t)=\\left\\{ \\begin{aligned} & \\frac{Q}{L\_k} && 若第k值蚂蚁在本次循环中从x到y\\\\ & 0 && 否则 \\end{aligned} \\right. \\end{equation} \\\]
        
        其中：
        
        *   \\(\\tau\_{xy}(t)\\)为当前路径上的信息素
        *   \\(\\Delta\\tau\_{xy}(t)\\)为路径（x, y）上信息素的增量
        *   \\(\\Delta\\tau^k\_{xy}(t)\\)为第k只蚂蚁留在路径（x, y）上的信息素的增量
        *   \\(Q\\)为常数
        *   \\(L\_k\\)为优化问题的目标函数值，表示第k只蚂蚁在本次循环中所走路径的长度
        
        蚂蚁圈系统利用的是全局信息 \\(Q/L\_k\\)，即蚂蚁完成一个循环后，更新所有路径上的信息。效果最好，通常作为蚁群优化算法的基本模型。
        
    *   蚂蚁数量系统（Ant-quantity System）
        
        \\\[\\begin{equation} \\Delta\\tau^k\_{xy}(t)=\\left\\{ \\begin{aligned} & \\frac{Q}{d\_k} && 若第k值蚂蚁在本次循环中从x到y\\\\ & 0 && 否则 \\end{aligned} \\right. \\end{equation} \\\]
        
        蚂蚁数量系统 利用的是局部信息 \\(Q/d\_k\\)，即蚂蚁每走一步都要更新残留信息素的浓度。
        
    *   蚂蚁密度系统（Ant-density System）
        
        \\\[\\begin{equation} \\Delta\\tau^k\_{xy}(t)=\\left\\{ \\begin{aligned} & Q && 若第k值蚂蚁在本次循环中从x到y\\\\ & 0 && 否则 \\end{aligned} \\right. \\end{equation} \\\]
        
        蚂蚁密度系统 利用的是局部信息 \\(Q\\)，即蚂蚁每走一步都要更新残留信息素的浓度。
        
*   全局信息更新方法的优点：
    
    *   保证了残留信息素不至于无限累积；
    *   如果路径没有被选中，那么上面的残留信息素会随时间的推移而逐渐减弱，这使算法能“忘记”不好的路径；
    *   即使路径经常被访问也不至于因为 \\(\\Delta\\tau^k\_{xy}(t)\\) 的累积，而产生 \\(\\Delta\\tau^k\_{xy}(t)\\gg\\eta\_{xy}(t)\\) 使期望值的作用无法体现；
    *   充分体现了算法中全局范围内较短路径(较好解)的生存能力；
    *   加强了信息正反馈性能；
    *   提高了系统搜索收敛的速度。

### 蚁群算法的参数选择

*   信息素启发因子 \\(\\alpha\\)
    *   反映了蚁群在路径搜索中随机性因素作用的强度；
    *   \\(\\alpha\\)值越大，蚂蚁选择以前走过的路径的可能性越大，搜索的随机性减弱；
    *   当 \\(\\alpha\\) 过大时会使蚁群的搜索过早陷于局部最优。
*   期望值启发式因子 \\(\\beta\\)
    *   反映了蚁群在路径搜索中先验性、确定性因素作用的强度；
    *   \\(\\beta\\)值越大，蚂蚁在某个局部点上选择局部最短路径的可能性越大；
    *   虽然搜索的收敛速度得以加快，但蚁群在最优路径的搜索过程中随机性减弱，易于陷入局部最优。
*   信息素挥发度 \\(1-\\rho\\)
    *   当要处理的问题规模比较大时，会使那些从来未被搜索到的路径(可行解) 上的信息量减小到接近于0，因而降低了算法的全局搜索能力；
    *   而且当 \\(1-\\rho\\) 过大时，以前搜索过的路径被再次选择的可能性过大，也会影响到算法的随机性能和全局搜索能力；
    *   反之，通过减小信息素挥发度 \\(1-\\rho\\) 虽然可以提高算法的随机性能和全局 搜索能力，但又会使算法的收敛速度降低。

### 蚁群算法的应用

  

本文转自 [https://www.cnblogs.com/AncilunKiang/p/16107544.html](https://www.cnblogs.com/AncilunKiang/p/16107544.html)，如有侵权，请联系删除。