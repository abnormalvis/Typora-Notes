C++ 标准库中的 `std::priority_queue`是一个容器适配器，它基于**堆（Heap）数据结构**实现，默认情况下提供的是**大顶堆（Max-Heap）**，这意味着优先级最高的元素（默认是值最大的元素）总是位于堆顶。

下面我来详细解释它的实现和用法。

### 🧠 核心实现原理

`std::priority_queue`的底层通常使用 `std::vector`或 `std::deque`作为容器来存储元素，并通过一套堆算法来维护堆的结构特性。

1. **堆的本质与维护**： 堆是一种**完全二叉树**，可以分为**最大堆**（父节点值 ≥ 子节点值）和**最小堆**（父节点值 ≤ 子节点值）。 为了维持堆的性质，在插入(`push`)或删除(`pop`)元素后需要进行调整，主要依靠两个核心操作： **上浮（Sift-up/Bubble-up）**：当新元素插入到堆的末尾时，如果其优先级高于父节点，则会与父节点交换，并不断向上比较和交换，直到满足堆的性质。 **下沉（Sift-down/Bubble-down）**：当移除堆顶元素（通常是将堆顶与最后一个元素交换后移除）后，新的堆顶元素可能会破坏堆的性质。这时会将其与优先级较高的子节点比较并交换，并不断向下调整，直到满足堆的性质。
2. **标准库的堆算法**： C++ 标准库提供了 `std::push_heap`、`std::pop_heap`、`std::make_heap`等函数来维护堆。`std::priority_queue`的 `push`和 `pop`成员函数内部通常会调用这些算法来确保底层容器始终满足堆的结构。

### 📦 模板参数

`std::priority_queue`是一个模板类，其声明如下：

```
template <
    class T,
    class Container = std::vector<T>,
    class Compare = std::less<typename Container::value_type>
> class priority_queue;
```

- **T**：存储的元素类型。
- **Container**：底层容器类型，必须满足*序列容器*的要求，并提供 `front()`, `push_back()`, `pop_back()`等操作，默认为 `std::vector<T>`。
- **Compare**：用于定义优先级的比较函数对象类型。默认为 `std::less<T>`，这会构造一个**大顶堆**（最大值在顶部）。你可以将其改为 `std::greater<T>`来构造一个**小顶堆**（最小值在顶部），或者提供自定义的比较器。

### ⚙️ 主要成员函数

| 函数名                    | 功能描述                                                     | 时间复杂度 |
| ------------------------- | ------------------------------------------------------------ | ---------- |
| `push(const T& value)`    | 将元素插入队列，并调整堆结构以维持性质                       | O(log n)   |
| `emplace(Args&&... args)` | 在队列中直接构造新元素，避免不必要的拷贝                     | O(log n)   |
| `pop()`                   | **移除**堆顶元素（优先级最高者），并调整堆结构。**注意：此函数不返回被移除的元素值** | O(log n)   |
| `top()`                   | **返回**堆顶元素（优先级最高者）的 **const 引用**。**不移除**元素 | O(1)       |
| `empty()`const            | 检查队列是否为空                                             | O(1)       |
| `size()`const             | 返回队列中元素的个数                                         | O(1)       |

### 🛠️ 基本用法示例

#### 默认行为（大顶堆）

```
#include <iostream>
#include <queue> // 包含 std::priority_queue

int main() {
    std::priority_queue<int> max_heap; // 默认大顶堆

    max_heap.push(30);
    max_heap.push(100);
    max_heap.push(25);
    max_heap.push(40);

    // 访问并弹出元素
    while (!max_heap.empty()) {
        std::cout << max_heap.top() << " "; // 每次输出当前最大值
        max_heap.pop();
    }
    // 输出: 100 40 30 25
    return 0;
}
```

#### 创建小顶堆

通过指定比较函数为 `std::greater<T>`来实现：

```
#include <iostream>
#include <queue>
#include <functional> // 如需使用 std::greater

int main() {
    // 注意模板参数的顺序：元素类型、底层容器、比较器类型
    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;

    min_heap.push(30);
    min_heap.push(100);
    min_heap.push(25);
    min_heap.push(40);

    while (!min_heap.empty()) {
        std::cout << min_heap.top() << " "; // 每次输出当前最小值
        min_heap.pop();
    }
    // 输出: 25 30 40 100
    return 0;
}
```

#### 自定义类型与比较规则

对于自定义类型（如结构体），你需要定义如何比较优先级。常见方法有：

1. **重载 `<`运算符**（适用于默认的 `std::less`，希望大的元素优先级高）： `struct Task {    int priority;    std::string name;     // 重载 < 运算符，priority 越大，优先级越高    bool operator<(const Task& other) const {        return priority < other.priority; // 注意：这里意味着优先级数值大的任务更“大”    } }; // 使用时可以直接使用默认的 priority_queue std::priority_queue<Task> task_queue; task_queue.push({5, "Low priority task"}); task_queue.push({10, "High priority task"}); // 高优先级的任务会先出队`
2. **自定义比较函数对象（Functor）**（更灵活，可定义多种规则）： `struct Task {    int priority;    std::string name; }; // 自定义比较器，希望 priority 值小的优先级高（小顶堆） struct CompareTask {    bool operator()(const Task& a, const Task& b) const {        // 返回 true 表示 a 的优先级应该低于 b        return a.priority > b.priority; // 如果 a.priority > b.priority，则 a 的优先级低于 b    } }; // 使用时需要显式指定比较器类型 std::priority_queue<Task, std::vector<Task>, CompareTask> task_queue; task_queue.push({5, "Low priority task"}); task_queue.push({10, "High priority task"}); // 此时 priority 值小的任务会先出队`

### ⚠️ 重要特性与注意事项

- **无迭代器支持**：`std::priority_queue`**不提供迭代器**来遍历所有元素。你只能访问堆顶元素 (`top()`)。这是因为它旨在高效地访问最高优先级的元素，而非遍历所有元素。
- **稳定性**：`std::priority_queue`是**不稳定**的，即当两个元素优先级相同时，它们出队的顺序并不保证与入队的顺序一致。
- **底层容器**：虽然默认是 `std::vector`，但你也可以选择 `std::deque`（`std::list`不行，因为它不支持随机访问）。
- **异常安全**：`push`和 `emplace`可能会在底层容器需要重新分配内存时抛出异常（如 `std::bad_alloc`）。`pop`通常保证不抛出异常（假设元素的移动或拷贝操作不抛异常）。

### 💡 典型应用场景

`std::priority_queue`在以下场景中非常有用：

- **任务调度**：操作系统或任务调度系统中，每次选择优先级最高的任务执行。
- **图算法**：如 **Dijkstra 算法**（寻找单源最短路径）和 **Prim 算法**（构造最小生成树），用于高效选取下一步要处理的最优节点。
- **数据流处理**：实时获取数据流中的最大或最小元素，或者解决 **Top K** 问题（从海量数据中找出最大或最小的 K 个元素）。
- **哈夫曼编码**：在构建哈夫曼树时，每次选择频率最小的两个节点进行合并。

希望这些信息能帮助你更好地理解和使用 C++ 中的 `std::priority_queue`。