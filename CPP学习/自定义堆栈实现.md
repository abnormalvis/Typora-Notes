下面我将为你介绍如何使用 C/C++ 实现堆栈数据结构（不使用 STL 容器），包括**数组**和**链表**两种实现方式，并提供完整的代码示例。

# 🖥️ C/C++ 堆栈(Stack)实现指南

堆栈是一种重要的**后进先出 (LIFO)** 数据结构，插入和删除操作都在同一端（称为栈顶）进行。下面我将详细介绍如何使用数组和链表两种方式来实现堆栈，并提供完整的代码示例。

## 1. 堆栈的基本概念与操作

堆栈的核心操作包括：

- **Push (入栈)**：将一个元素放入堆栈顶部
- **Pop (出栈)**：从堆栈顶部移除并返回元素
- **Peek/Top (查看栈顶)**：获取顶部元素的值而不删除它
- **IsEmpty (判空)**：检查堆栈是否为空
- **IsFull (判满)**：检查堆栈是否已满（主要用于数组实现）

## 2. 数组实现堆栈

数组实现使用连续内存空间，通过一个栈顶指针来跟踪当前栈顶位置。

### 2.1 结构定义

```
#define MAX_SIZE 100  // 堆栈最大容量

template <typename T>
class ArrayStack {
private:
    T data[MAX_SIZE];  // 存储堆栈元素的数组
    int top;           // 栈顶指针（索引）
    
public:
    ArrayStack() : top(-1) {}  // 初始化栈顶指针为-1（空栈）
    
    // 基本操作函数
    bool push(T element);
    T pop();
    T peek();
    bool isEmpty();
    bool isFull();
};
```

### 2.2 核心操作实现

```
// 判断堆栈是否已满
template <typename T>
bool ArrayStack<T>::isFull() {
    return top == MAX_SIZE - 1;
}

// 判断堆栈是否为空
template <typename T>
bool ArrayStack<T>::isEmpty() {
    return top == -1;
}

// 入栈操作
template <typename T>
bool ArrayStack<T>::push(T element) {
    if (isFull()) {
        std::cout << "堆栈已满，无法压栈！" << std::endl;
        return false;
    }
    data[++top] = element;  // 栈顶指针先加1，再存入元素
    return true;
}

// 出栈操作
template <typename T>
T ArrayStack<T>::pop() {
    if (isEmpty()) {
        std::cout << "堆栈为空，无法出栈！" << std::endl;
        return T();  // 返回默认值
    }
    return data[top--];  // 返回栈顶元素，然后指针减1
}

// 查看栈顶元素
template <typename T>
T ArrayStack<T>::peek() {
    if (isEmpty()) {
        std::cout << "堆栈为空！" << std::endl;
        return T();
    }
    return data[top];
}
```

### 2.3 数组实现的优缺点

- **优点**：实现简单、访问速度快、内存开销小
- **缺点**：容量固定、可能发生栈溢出

## 3. 链表实现堆栈

链表实现使用动态内存分配，每个元素都是一个节点，包含数据和指向下一个节点的指针。

### 3.1 结构定义

```
template <typename T>
class ListNode {
public:
    T data;
    ListNode* next;
    
    ListNode(T value) : data(value), next(nullptr) {}
};

template <typename T>
class LinkedListStack {
private:
    ListNode<T>* top;  // 栈顶指针
    
public:
    LinkedListStack() : top(nullptr) {}  // 初始化空栈
    
    // 基本操作函数
    void push(T element);
    T pop();
    T peek();
    bool isEmpty();
    ~LinkedListStack();  // 析构函数用于释放内存
};
```

### 3.2 核心操作实现

```
// 判断堆栈是否为空
template <typename T>
bool LinkedListStack<T>::isEmpty() {
    return top == nullptr;
}

// 入栈操作
template <typename T>
void LinkedListStack<T>::push(T element) {
    ListNode<T>* newNode = new ListNode<T>(element);
    newNode->next = top;  // 新节点指向当前栈顶
    top = newNode;        // 更新栈顶为新节点
}

// 出栈操作
template <typename T>
T LinkedListStack<T>::pop() {
    if (isEmpty()) {
        std::cout << "堆栈为空，无法出栈！" << std::endl;
        return T();
    }
    
    ListNode<T>* temp = top;  // 保存当前栈顶
    T poppedValue = top->data; // 保存要返回的值
    top = top->next;          // 更新栈顶为下一个节点
    delete temp;              // 释放原栈顶内存
    
    return poppedValue;
}

// 查看栈顶元素
template <typename T>
T LinkedListStack<T>::peek() {
    if (isEmpty()) {
        std::cout << "堆栈为空！" << std::endl;
        return T();
    }
    return top->data;
}

// 析构函数 - 释放所有节点内存
template <typename T>
LinkedListStack<T>::~LinkedListStack() {
    while (!isEmpty()) {
        pop();
    }
}
```

### 3.3 链表实现的优缺点

- **优点**：动态容量、不会溢出（除非内存耗尽）、内存使用高效
- **缺点**：实现稍复杂、每个元素需要额外指针空间、访问速度稍慢

## 4. 完整示例代码

以下是一个使用数组实现堆栈的完整示例：

```
#include <iostream>
#include <string>

#define MAX_SIZE 100

template <typename T>
class ArrayStack {
private:
    T data[MAX_SIZE];
    int top;
    
public:
    ArrayStack() : top(-1) {}
    
    bool push(T element) {
        if (isFull()) {
            std::cout << "堆栈已满，无法压栈！" << std::endl;
            return false;
        }
        data[++top] = element;
        return true;
    }
    
    T pop() {
        if (isEmpty()) {
            std::cout << "堆栈为空，无法出栈！" << std::endl;
            return T();
        }
        return data[top--];
    }
    
    T peek() {
        if (isEmpty()) {
            std::cout << "堆栈为空！" << std::endl;
            return T();
        }
        return data[top];
    }
    
    bool isEmpty() {
        return top == -1;
    }
    
    bool isFull() {
        return top == MAX_SIZE - 1;
    }
    
    int size() {
        return top + 1;
    }
};

int main() {
    ArrayStack<std::string> stack;
    
    // 压入一些元素
    stack.push("Hello");
    stack.push("World");
    stack.push("C++");
    stack.push("Stack");
    
    std::cout << "堆栈大小: " << stack.size() << std::endl;
    std::cout << "栈顶元素: " << stack.peek() << std::endl;
    
    // 弹出所有元素
    std::cout << "\n出栈顺序:" << std::endl;
    while (!stack.isEmpty()) {
        std::cout << stack.pop() << std::endl;
    }
    
    return 0;
}
```

## 5. 实现堆栈的关键要点

1. **栈顶指针管理**：无论是数组还是链表实现，都需要准确维护栈顶指针。
2. **边界条件处理**：始终在操作前检查栈空或栈满条件。
3. **内存管理**：链表实现需要特别注意内存管理，确保出栈时释放节点内存。
4. **模板化设计**：使用模板可以使堆栈支持多种数据类型。
5. **异常处理**：考虑添加异常处理机制，使代码更健壮（上述示例为简化使用简单返回值）。

## 6. 堆栈的应用场景

堆栈在计算机科学中有广泛的应用：

- **表达式求值**：中缀表达式转后缀表达式，后缀表达式求值
- **函数调用**：保存函数调用上下文和返回地址
- **回溯算法**：如深度优先搜索、迷宫求解
- **撤销机制**：许多应用程序中的撤销(Undo)功能
- **括号匹配**：检查代码中的括号是否正确匹配

## 总结

选择数组还是链表实现堆栈取决于具体应用需求。**数组实现**更适合需要**高性能和确定性内存使用**的场景，而**链表实现**则更适合需要**动态增长和不确定元素数量**的场景。两种实现方式都避免了使用STL容器，提供了对内存和操作的完全控制。

希望本指南帮助你理解了如何实现自己的堆栈数据结构。如果你有特定应用场景或性能需求，可以根据这些基础实现进行优化和扩展。