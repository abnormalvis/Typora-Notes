一阶低通和高通滤波是数字信号处理中非常基础且实用的算法，它们能有效地从信号中提取出我们需要的频率成分。下面我将为你讲解它们的实现原理、代码示例以及典型应用。

# 🔍 一阶低通与高通滤波算法：从原理到实践

## ✨ 一、滤波算法基础

在信号处理中，**滤波**的核心目的是**有选择地让特定频率范围的信号通过，同时抑制其他频率成分**。一阶低通滤波器 (Low-Pass Filter, LPF) 允许低频信号通过而衰减高频信号，常用于**平滑数据**和**去除高频噪声**；一阶高通滤波器 (High-Pass Filter, HPF) 则允许高频信号通过而抑制低频信号，常用于**分离变化分量**和**消除基线漂移**。它们都是从模拟RC滤波器演变而来，通过软件算法在数字领域实现。

## 📉 二、一阶低通滤波算法

### 1. 算法原理

一阶低通滤波器的核心是一个**递归公式**，通过对当前采样值和上一次滤波输出值进行**加权平均**来实现：

**核心公式：**

```
Y(n) = α * X(n) + (1 - α) * Y(n-1)
```

- `Y(n)`：本次滤波输出值
- `X(n)`：本次采样值
- `Y(n-1)`：上次滤波输出值
- `α`：**滤波系数**，取值范围为0~1

**滤波系数 α 的确定：**

α 的取值直接影响滤波器的特性，它与系统的时间常数（τ）和采样周期（Ts）密切相关：

```
α = Ts / (Ts + τ)
```

其中时间常数 `τ = 1 / (2π * fc)`，`fc`是期望的**截止频率**。这意味着你可以通过设定目标截止频率和你的系统采样周期来计算所需的α值。

**滤波系数的影响：**

- **α 值较大**（接近1）：滤波器**灵敏度高**，响应速度快，但平滑效果差，输出波动较大（更接近原始信号）。
- **α 值较小**（接近0）：滤波器**稳定度高**，平滑效果好，但响应速度慢，滞后明显（输出更平坦）。

### 2. 代码实现

**C语言实现：**

```
#define ALPHA 0.2 // 滤波系数，根据实际需求调整

float first_order_low_pass_filter(float new_sample, float last_output) {
    return ALPHA * new_sample + (1 - ALPHA) * last_output;
}

// 使用示例
float raw_data_read = 50.0; // 假设从传感器读取的新值
static float filtered_value = 0.0; // 静态变量保存上一次滤波结果

filtered_value = first_order_low_pass_filter(raw_data_read, filtered_value);
```

*这是一个非常基础的实现，在实际项目中你可能需要处理首次调用等边界情况。*

**Python实现：**

```
class FirstOrderLowPassFilter:
    def __init__(self, alpha):
        self.alpha = alpha
        self.previous_output = None

    def filter(self, input_value):
        if self.previous_output is None:
            self.previous_output = input_value # 初始化
        output = self.alpha * input_value + (1 - self.alpha) * self.previous_output
        self.previous_output = output
        return output

# 使用示例
import numpy as np
import matplotlib.pyplot as plt

# 生成一个带高频噪声的信号
fs = 1000 # 采样频率1000Hz
t = np.linspace(0, 1, fs)
signal_clean = np.sin(2 * np.pi * 5 * t) # 5Hz纯净正弦波
signal_noisy = signal_clean + 0.6 * np.random.randn(len(t)) # 加入随机噪声

# 创建滤波器，设定截止频率约为10Hz，计算alpha
fc_desired = 10 # 期望截止频率
tau = 1 / (2 * np.pi * fc_desired)
Ts = 1 / fs
alpha_val = Ts / (Ts + tau)

lpf = FirstOrderLowPassFilter(alpha=alpha_val)
filtered_signal = np.zeros_like(signal_noisy)
for i, value in enumerate(signal_noisy):
    filtered_signal[i] = lpf.filter(value)

# 绘制结果
plt.figure(figsize=(10, 6))
plt.plot(t, signal_noisy, label='Noisy Signal', alpha=0.7)
plt.plot(t, signal_clean, label='Clean Signal', linestyle='--')
plt.plot(t, filtered_signal, label='Filtered Signal', linewidth=2, color='red')
plt.legend()
plt.title('First Order Low-Pass Filter Effect')
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.grid(True)
plt.show()
```

### 3. 应用场景

一阶低通滤波器在以下场景中非常有用：

- **传感器数据平滑**：消除振动、温度、压力等传感器读数中的随机高频噪声，使数据更稳定可靠。
- **电机控制**：平滑转速或转矩的控制信号，防止高频分量导致系统振荡或不稳定。
- **音频处理**：用作简单的高音衰减或消除录音中的嘶嘶声（高频噪声）。

## 📈 三、一阶高通滤波算法

### 1. 算法原理

一阶高通滤波器的核心思想是**消除信号的直流分量或低频漂移，同时保留其高频变化部分**。

**核心公式（常见离散形式之一）：**

```
Y(n) = α * [Y(n-1) + X(n) - X(n-1)]
```

- `Y(n)`：本次滤波输出值
- `X(n)`：本次采样值
- `X(n-1)`：上次采样值
- `Y(n-1)`：上次滤波输出值
- `α`：**滤波系数**，通常由截止频率和采样率决定

**另一种理解与公式：**

高通滤波也可以看作是**从原始信号中减去其自身的低通滤波结果**，从而得到高频成分：

```
Y_highpass(n) = X(n) - Y_lowpass(n)
```

这直观地反映了高通与低通之间的互补关系。

滤波系数 `α`的计算同样与截止频率 `fc`和采样周期 `Ts`有关，通常可通过 `α = RC / (Ts + RC)`或类似方法求得，其中 `RC = 1/(2πfc)`。

### 2. 代码实现

**C语言实现：**

```
// 一阶高通滤波器结构体，用于保存状态
typedef struct {
    float last_input; // 保存上一次输入值
    float last_output; // 保存上一次输出值
    float alpha; // 滤波系数
} HighPassFilter;

float first_order_high_pass_filter(HighPassFilter* filter, float current_input) {
    float output = filter->alpha * (filter->last_output + current_input - filter->last_input);
    filter->last_input = current_input; // 更新状态
    filter->last_output = output;
    return output;
}

// 初始化滤波器
HighPassFilter hpf;
hpf.alpha = 0.1; // 根据需求设置alpha
hpf.last_input = 0.0;
hpf.last_output = 0.0;

// 使用时，每次传入新采样值
float new_data = ...; // 获取新数据
float filtered_data = first_order_high_pass_filter(&hpf, new_data);
```

**Python实现：**

```
class FirstOrderHighPassFilter:
    def __init__(self, cutoff_freq, sample_rate):
        # 通过截止频率和采样率计算alpha
        rc = 1.0 / (2 * np.pi * cutoff_freq)
        dt = 1.0 / sample_rate
        self.alpha = rc / (rc + dt)
        self.prev_input = 0.0
        self.prev_output = 0.0

    def filter(self, input_value):
        # 应用滤波公式: Y(n) = α * [Y(n-1) + X(n) - X(n-1)]
        output = self.alpha * (self.prev_output + input_value - self.prev_input)
        self.prev_input = input_value
        self.prev_output = output
        return output

# 使用示例
# 生成一个混合信号：低频漂移 + 高频正弦波
t = np.linspace(0, 1, 1000)
low_freq_drift = 0.5 * np.sin(2 * np.pi * 1 * t) # 1Hz低频漂移
high_freq_signal = 0.8 * np.sin(2 * np.pi * 20 * t) # 20Hz高频信号
mixed_signal = low_freq_drift + high_freq_signal

# 创建高通滤波器，截止频率设为5Hz，旨在去除低频漂移
cutoff_freq_hp = 5 # Hz
sample_rate = 1000 # Hz
hpf = FirstOrderHighPassFilter(cutoff_freq_hp, sample_rate)

filtered_signal_hp = np.zeros_like(mixed_signal)
for i, value in enumerate(mixed_signal):
    filtered_signal_hp[i] = hpf.filter(value)

# 绘制结果
plt.figure(figsize=(10, 6))
plt.plot(t, mixed_signal, label='Mixed Signal (1Hz drift + 20Hz wave)', alpha=0.7)
plt.plot(t, high_freq_signal, label='Pure High Freq (20Hz)', linestyle='--')
plt.plot(t, filtered_signal_hp, label='High-Pass Filtered', linewidth=2, color='red')
plt.legend()
plt.title('First Order High-Pass Filter Effect')
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.grid(True)
plt.show()
```

*这个Python示例展示了高通滤波器如何有效地从混合信号中分离出高频成分。*

### 3. 应用场景

一阶高通滤波器的典型应用包括：

- **消除基线漂移**：在心电图（ECG）、脑电图（EEG）等生物电信号中，去除由呼吸或运动引起的低频漂移，保留代表心跳或脑电活动的较高频率成分。
- **边缘检测与图像锐化**：在图像处理中，高通滤波器可用于增强图像的边缘和细节（高频信息），实现锐化效果或某些艺术特效（如浮雕效果）。
- **交流耦合**：在电路设计中，模拟高通滤波器的思想常用于通过电容隔离直流信号，仅传递交流分量。

## 🔮 四、如何选择与使用

### 低通与高通滤波的特性对比

| 特性         | 一阶低通滤波器 (LPF)                  | 一阶高通滤波器 (HPF)                                      |
| ------------ | ------------------------------------- | --------------------------------------------------------- |
| **核心功能** | 保留低频，抑制高频                    | 保留高频，抑制低频                                        |
| **输出特性** | 平滑、稳定                            | 突出变化、细节                                            |
| **关键参数** | 滤波系数 α (0~1)                      | 滤波系数 α                                                |
| **α 的影响** | α↑：响应快，平滑差 α↓：响应慢，平滑好 | α↑：截止频率低，通过更多低频 α↓：截止频率高，通过更多高频 |
| **典型应用** | 传感器去噪、数据平滑、音频高音衰减    | 消除基线漂移、边缘检测、交流耦合                          |

### 实用建议

1. **参数调整是关键**：滤波系数 `α`（或截止频率 `fc`）没有绝对的最优值，需要根据你的**信号特性**（频率范围）和**应用需求**（响应速度与平滑度的权衡）进行实际调试。
2. **注意相位滞后**：一阶递归滤波器会引入**相位延迟**，这在闭环控制系统中可能需要特别注意。
3. **初始化问题**：滤波器第一次使用时，`Y(n-1)`的初始值通常设置为第一次的采样值 `X(0)`，否则可能需要一定时间才能达到稳定状态。
4. **计算开销**：一阶滤波算法计算量很小，非常适合在**单片机**、**嵌入式系统**或需要**实时处理**的场合中使用。
5. **局限性**：一阶滤波器在截止频率附近的衰减斜率较平缓（-20dB/十倍频程），**阻带抑制性能**有限。对于要求较高的应用，可能需要考虑二阶或更高阶的滤波器。

## 💎 总结

一阶低通和高通滤波算法是信号处理中简洁而强大的工具。低通滤波善于**平滑数据、净化信号**，宛如给数据加上一层“防抖”功能；而高通滤波善于**捕捉变化、提取细节**，如同给信号装上“锐眼”。它们的核心公式并不复杂，通过调整一个关键参数 `α`就能适应多种场景。

理解其原理并掌握其实现，能帮助你在处理传感器数据、进行音频图像分析或设计控制系统时更加得心应手。