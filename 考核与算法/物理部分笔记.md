以下是对您提供的三个文件内容的详细归纳、总结与分析。这些题目主要涵盖**物理常识**、**算法常识**和**C++编程基础**，涉及动力学建模、数字信号处理、基础语法、算法实现和面向对象编程等内容。我将按文件顺序逐一分析，并提取关键知识点。

---

## 一、物理常识部分（12分）

### 题目背景：
平衡步兵是RoboMaster赛事中的一种机器人，通过姿态传感器和伺服控制系统维持平衡。题目要求对简化后的车体进行动力学分析。

#### ① 系统类型判断
- **问题**：该系统属于惯性系统还是非惯性系统？
- **答案**：非惯性系统。
- **分析**：因为车体在运动过程中存在加速度，参考系为非惯性系，需考虑惯性力。

#### ② 转矩与加速度方向
- **问题**：当机体向前倾倒时，轮子的转矩方向、轮子加速度方向、摆杆加速度方向。
- **答案**：
  - 轮子转矩方向：顺时针
  - 轮子加速度方向：水平向前
  - 摆杆加速度方向：水平向后
- **分析**：为抵抗向前倾倒，轮子需产生向前加速度，转矩顺时针（从左侧视图），摆杆因惯性相对向后加速。

#### ③ 回复力条件计算
- **问题**：给定 
  $$
  a = k\theta
  $$
  ，求使机体往回摆的条件。
- **答案**： 
  $$
  k > g
  $$
  
- **推导过程**：
  
  - 回复力公式：
    $$
    F = mg\sin\theta - ma\cos\theta\
    $$
    
  - 小角度近似：
    $$
    \sin\theta \approx \theta, \cos\theta \approx 1
    $$
    
  - 代入
    $$
    a = k\theta
    $$
  
    $$
    F = mg\theta - mk\theta = m\theta(g - k)
    $$
  
    
  - 回复力需向后:
    $$
     F < 0 \Rightarrow k > g
    $$
    

---

## 二、算法常识部分（13分）

### 题目背景：
使用一阶数字低通滤波器处理传感器信号，公式为：
$$
y(k) = (1-a) \cdot y(k-1) + a \cdot x(k)
$$

#### ① 动态响应优化
- **问题**：如何提高动态响应？为什么？
- **答案**：增大截止频率（即增大 a，因为当前输入 \(x(k) x(k) \) 权重增大，跟踪效果更好。
- **分析**： a越大，滤波器对当前输入越敏感，响应更快，但平滑度下降。

#### ② 噪声过滤
- **问题**：噪声过大时如何处理？
- **答案**：减小截止频率（即减小a，因为当前输入权重减小，输出更平滑。
- **分析**：a越小，历史输出权重越大，对噪声的抑制更强。

#### ③ 与卡尔曼滤波的比较
- **问题**：指出与卡尔曼滤波最后一式的相似处。
- **答案**：
  - 一阶低通滤波公式可改写为：
    $$
    y(k) = y(k-1) + a \cdot (x(k) - y(k-1))
    $$
    
  - 与卡尔曼滤波更新式：
    $$
    \hat{x}_k = \hat{x}_k^* + K_k(z_k - H\hat{x}_k^*)
    $$
    
  - 相似点：两者都是“预测 + 修正”结构，一阶低通滤波相当于卡尔曼增益 \( K_k \) 固定为 \( a \)、测量矩阵 \( H = 1 \) 的特例。
- **分析**：卡尔曼滤波在收敛后增益稳定，效果类似于低通滤波。

---

## 三、笔试题目部分（C++编程）

### 1. 填空题
#### ① 表达式计算
- **代码**：
  ```cpp
  float x = 3.5, y = 4.1;
  int a = 7;
  int b = x + a % 3 * static_cast<int>(x + y) % 2 / 4;
  ```
- **答案**：b = 3
- **分析**：
  - `a % 3 = 1`
  - `static_cast<int>(x + y) = 7`
  - `1 * 7 % 2 = 1`
  - `1 / 4 = 0`（整数除法）
  - `b = 3.5 + 0 = 3`（赋值给 int 截断）

#### ② 自增运算符
- **代码**：
  ```cpp
  z = (++x) + (y++);
  ```
- **答案**：x = 1, y = 2, z = 2
- **分析**：
  - `++x` 先增为1，`y++` 先用1后增为2
  - `z = 1 + 1 = 2`

#### ③ 数组指针
- **代码**：
  ```cpp
  int a[] = {1, 3, 6, 9, 4};
  *(a + 1) = ?
  ```
- **答案**：3
- **分析**：`a + 1` 指向第二个元素 `a[1] = 3`

---

### 2. 算法题

#### ① 杨辉三角
- **要求**：输出前 n 行杨辉三角
- **关键代码**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      a[i][1] = a[i][i] = 1;
      for (int j = 2; j < i; j++)
          a[i][j] = a[i-1][j] + a[i-1][j-1];
  }
  ```
- **分析**：典型动态规划思路，每行首尾为1，中间元素为上一行相邻元素之和。

#### ② Swap函数实现
- **要求**：实现交换两个整数的函数
- **关键代码**：
  ```cpp
  void swap(int* x, int* y) {
      int temp = *x;
      *x = *y;
      *y = temp;
  }
  ```
- **分析**：使用指针传递实参，直接修改内存值。

#### ③ Vector比较
- **要求**：比较两个 `vector<int>` 是否相等
- **关键代码**：
  ```cpp
  if (a == b) printf("equal\n");
  else printf("not equal\n");
  ```
- **分析**：`vector` 重载了 `==` 运算符，可逐元素比较。

#### ④ 类继承与多态
- **要求**：
  - 基类 `ChassisBase` 含虚函数 `moveJoint` 和实现函数 `odometry`
  - 子类 `Omni` 和 `Mecanum` 重写 `moveJoint`
- **关键代码**：
  ```cpp
  class ChassisBase {
  public:
      virtual void moveJoint() = 0;
      void odometry() { cout << "ChassisBase odometry." << endl; }
  };
  class Omni : public ChassisBase {
      void moveJoint() { cout << "Omni moveJoint." << endl; }
  };
  class Mecanum : public ChassisBase {
      void moveJoint() { cout << "Mecanum moveJoint." << endl; }
  };
  ```
- **分析**：使用纯虚函数实现接口，子类重写具体行为。

#### ⑤ Target类分类
- **要求**：根据 `id_` 将目标分到三个容器
- **关键代码**：
  ```cpp
  for (auto target : targets) {
      if (target.id_ == 0) id_0_targets.push_back(target);
      else if (target.id_ == 1) id_1_targets.push_back(target);
      else if (target.id_ == 2) id_2_targets.push_back(target);
  }
  ```
- **分析**：遍历容器，使用条件判断分类存储。

